<!DOCTYPE html>
<meta charset='utf-8'>

<head>
    <title>Bubble tree</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.0.1/d3.min.js"></script>
    <script src="./data/data2.js"></script>
</head>

<style>
</style>

<div id="chart">

</div>

<script>
    const width = 1400;
    const height = 750;

    // Prepare our physical space
    const svg = d3
        .select('#chart')
        .append('svg')
        .attr('width', width)
        .attr('height', height)

    const g = svg.append('g')
        .attr('transform', "translate(20,50)");

    const colorScale = d3.scaleOrdinal()
        .domain(["level1", "level2", "level3", "level4", "level5", "level6"])
        .range(["#49006a", "#7a0177", "#c51b8a", "#f768a1", "#fa9fb5", "#fcc5c0", "#feebe2"]);

    const fontScale = d3.scaleOrdinal()
        .domain(["1", "2", "3", "4", "5", "6"])
        .range([9, 9, 9, 7, 7, 5.5]);

    //prepare data
    const reduceFn =
        data => d3.sum(data, d => d.count);

    const groupingFns = [d => d.base, d => d.base2, d => d.sugar, d => d.fruit, d => d.texture, d => d.drinkEN]

    const rollupData = d3.rollup(data, reduceFn, ...groupingFns);

    const childrenAccessorFn = ([key, value]) => value.size && Array.from(value)

    const hierarchyData = d3.hierarchy([null, rollupData], childrenAccessorFn)
        .sum(([key, value]) => value)
        .sort((a, b) => b.value - a.value)

    // Declare d3 layout
    const vLayout = d3.tree().size([width * 0.98, height * 0.85]);

    // Layout + Data
    const vRoot = hierarchyData;
    const vNodes = vRoot.descendants();
    const vLinks = vLayout(vRoot).links();

    const filterData = (targetHeight) => (vLinks.filter(d => d.target.height == targetHeight))

    const level1Data = filterData(5);
    const level2Data = filterData(4);
    const level3Data = filterData(3);
    const level4Data = filterData(2);
    const level5Data = filterData(1);
    const level6Data = filterData(0);

    const wrap = (text, width) => {
        text.each(function () {
            var text = d3.select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 1, //<-- 0!
                lineHeight = 1.1, // ems
                x = text.attr("x"), //<-- include the x!
                y = text.attr("y"),
                dy = text.attr("dy") ? text.attr("dy") : 0; //<-- null check
            tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                }
            }
        });
    }


    const drawViz = (className, data) => {

        g.selectAll(`path.${className}`).data(data).join('path')
            .attr("class", className)
            .attr('d', d3.linkVertical()
                .x(function (d) { return d.x; })
                .y(function (d) { return d.y; }))

            .attr("stroke-dasharray", function () {
                const totalLength = this.getTotalLength();
                return totalLength + " " + totalLength;
            })
            .attr("stroke-dashoffset", function () {
                const totalLength = this.getTotalLength();
                return totalLength;
            })
            .transition()
            .duration(1500)
            .attr("stroke-dashoffset", 0)
            .attr("opacity", 0.7)
            .attr("stroke-width", 1.5)
            .attr("fill", "none")
            .attr("stroke", colorScale(className))
    }

    const drawText = (className, data) => {
        g.selectAll(`text.${className}`).data(data).join('text')
            .attr("class", className)
            .attr("x", d => d.target.x)
            .attr("y", d => d.target.y)
            .attr("dy", 1)
            .style("font-size", fontScale(className.charAt(5)))
            .style("font-family", 'Roboto')
            .attr("text-anchor", "middle")
            .text(d => d.target.data[0])
            .call(wrap, 24);
    }


    const drawDelay = (className, data, classNameText, dataText, time, viz) => {
        setTimeout(
            function () {
                if (viz) { drawViz(className, data); }
                drawText(classNameText, dataText)
            }, time);

    }

    drawViz("level1", level1Data);
    drawDelay("level2", level2Data, "level1Text", level1Data, 1500, true);
    drawDelay("level3", level3Data, "level2Text", level2Data, 3000, true);
    drawDelay("level4", level4Data, "level3Text", level3Data, 4500, true);
    drawDelay("level5", level5Data, "level4Text", level4Data, 6000, true);
    drawDelay("level6", level6Data, "level5Text", level5Data, 7500, true);
    drawDelay("level6", level6Data, "level6Text", level6Data, 9000, false);


</script>